git token:  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

十次方：root itcast     数据库 root  root
畅购商城：虚拟机和数据库：  192.168.211.132  root  root

IDEA快捷键速记：
自动补全返回值 ：	ctrl+alt+v
格式化import列表 ：Ctrl+Alt+o
格式化代码	：Ctrl+Alt+l
新建	：Alt+insert
自动补全代码	：Ctrl+shift+space

MQ使用情景：用户模块给用户发送验证码
--
systemctl start docker :   启动容器
docker images:   列出镜像
docker search mysql: 在镜像仓库中查找镜像（默认是docker hub,可以指定国内的镜像仓库）
docker pull XXX:     拉取镜像
docker rmi XXX:   删除镜像

docker ps:      查看正在运行的容器
docker ps -a:   查看历史运行的容器
docker run:     创建容器
docker rm XXX:  删除容器
docker start XXX:   启动容器 
docker restart 1b4671904bfa
docker exec ：在运行的容器中执行命令


启动Redis
docker run -di --name=rensquare_mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root centos/mysql-57-centos7
docker run -di --name=tenquare_mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=itcast XXX(:version不是最新版本)


https://blog.csdn.net/qq_36252295/article/details/122620663
docker run -di --name mysql8 --privileged=true -p 3307:3306 -v /home/mysql/conf:/etc/mysql/my.cnf -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root mysql:latest
启动MongoDB
docker run --name=tensquare_mongo -p 27017:27017 mongo
启动elasticsearch
docker run -di --name=tensquare_es -p 9200:9200 -p 9300:9300 elasticsearch:5.6.8

DOS下启动Head插件
grunt server


进入容器
docker exec -it 775c7c9ee1e1 /bin/bash

进入mysql
mysql -uroot -p123456

查看最大连接数
show variables like '%max_connections%';

修改最大连接数
set GLOBAL max_connections = 2000;

查看最大连接数
show variables like '%max_connections%';

退出mysql
exit

修改配置文件最大连接数（避免重启后需要重新设置）
系统：ubuntu

:cd /etc/mysql

:vi my.cnf

添加配置

max_connections=2000
――――――――――――――――
版权声明：本文为CSDN博主「qq_26372385」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_26372385/article/details/95593094
http://wallls.com/wallpaper/198911/

修改容器里的配置文件：
1.先 docker exec -it 容器名 /bin/bash
2.进入config目录下
3.vi elasticsearch.yml 因为容器没有vi命令，不能修改。所以只能在宿主机里挂载一个文件映射ES的配置文件。
4.exit 退出容器
5.docker cp tensquare_es:/usr/share/elasticsearch/config/elasticsearch.yml /usr/share/elasticsearch.yml
6.docker stop tensquare_es 
7.重新启动容器 docker run -di --name=tensquare_es -p 9200:9200 -p 9300:9300 -v /usr/share/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml elasticsearch:5.6.8
8.vi /usr/share/elasticsearch.yml 文件 将第一行注释解除
9.为使文件生效需要 docker restart tensquare_es 
10.重启后几分钟后 docker ps 发现容器挂了，这时就需要系统调优
修改/etc/security/limits.conf ，追加内容
* soft nofile 65536
* hard nofile 65536

nofile是单个进程允许打开的最大文件个数 soft nofile 是软限制 hard nofile是硬限制


修改/etc/sysctl.conf，追加内容
vm.max_map_count=655360
限制一个进程可以拥有的VMA(虚拟内存区域)的数量
执行下面命令 修改内核参数马上生效
sysctl \p     (貌似没有用，要执行第11步重启虚拟机 )
11. reboot 重新启动虚拟机，再次启动容器，发现已经可以启动并远程访问



关于使用SpringCache进行缓存数据库查询

1、在SpringBoot的启动类上添加注解@EnableCaching，开启SpringCache缓存支持
@SpringBootApplication
// 开启SpringCache缓存支持
@EnableCaching
public class GatheringApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatheringApplication.class, args);
    }
}

2、在service的方法上添加对应的注解

/**
 * 根据ID查询
 *
 * @param id
 * @return
 */
// 使用SpringCache进行缓存数据库查询
@Cacheable(value = "gathering", key = "#id")
public Gathering findById(String id) {
    return gatheringDao.findById(id).get();
}
/**
 * 修改
 *
 * @param gathering
 */
// 修改数据库数据后需要删除redis中的缓存
@CacheEvict(value = "gathering", key = "#gathering.id")
public void update(Gathering gathering) {
    gatheringDao.save(gathering);
}
 
/**
 * 删除
 *
 * @param id
 */
// 删除数据库数据后需要删除redis中的缓存
@CacheEvict(value = "gathering", key = "#id")
public void deleteById(String id) {
    gatheringDao.deleteById(id);
}


简历可补充内容：xxl-job任务调度框架


spring 的拦截器
@Component
public class JwtInterceptor implements HandlerInterceptor {

  @Override
  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
      throws Exception {
    System.out.println("经过了拦截器");
    //true：放行 false：阻塞
    return true;
  }
}


拦截器的配置类 （配置拦截器对象和拦截路径）
@Configuration
public class InterceptorConfig extends WebMvcConfigurationSupport {

  @Autowired
  private JwtInterceptor jwtInterceptor;
  @Override
  protected void addInterceptors(InterceptorRegistry registry) {
    //注册拦截器要声明拦截器对象和要拦截的路径
    registry.addInterceptor(jwtInterceptor)
      .addPathPatterns("/**")
      .excludePathPatterns("/login/**");
  }
}

基于SpringBoot的定时任务
启动类中需要加注解@EnableScheduling
执行定时任务的类中执行任务的方法上需要加注解@Scheduled(cron = "${配置文件}")，同一个类中可以配置多个任务的方法

SpringBoot和SpringCloud的关系
SpringBoot是Spring的一套快速配置脚手架，可以基于SpringBoot快速开发单个微服务，SpringCloud是一个基于SpringBoot实现的云应用开发工具；SpringBoot专注于快速、方便集成的单个微服务个体，SpringCloud
则关注全局的服务治理框架。


跨域：A域名访问B域名的数据
			域名或者请求端口或者协议不一致的时候，就跨域了。
	eg:www.abc.com html   www.abc.cn
		 www.abc.com:10002  www.abc.com:10003
		 http://    https://


springboot 注解
@SpringBootApplication
@Bean
@RestController   注解可以将对象转json 省去注解@ResponseBody
@CrossOrigin   跨域
@RequestMapping
@Autowired
@Service
@Transactional
@Component 把普通的pojo 实例化到spring容器中，相当于配置文件中的<bean id="" class=""/>
@RequestBody
@ResponseBody
@PathVariable
@EnableCaching 加在启动类上，开启SpringBoot Cache
@Cacheable(value = "gathering", key = "#id")
@CacheEvict(value = "gathering", key = "#gathering.id")



使用springboot分页：
dao层方法：
 public Page<Article> findByTitleOrContentLike(String title, String content, Pageable pageable);

service层方法：

public Page<Article> findByKey(String key, int page, int size) {
    Pageable pageable = PageRequest.of(page-1, size);
    return articleDao.findByTitleOrContentLike(key, key, pageable);
  }
controller层方法：
@RequestMapping(value = "/{key}/{page}/{size}", method = RequestMethod.GET)
  public Result findByKey(@PathVariable String key, @PathVariable int page, @PathVariable int size){

     Page<Article> pageData = articleService.findByKey(key, page, size);
     return new Result(true, StatusCode.OK, "查询成功", new PageResult<Article>(pageData.getTotalElements(), pageData.getContent()));
  }
  
//Apache的lang包常用的方法  
package org.apache.commons.lang;
//生成随机数
String checkCode = RandomStringUtils.randomNumeric(6);

//判断字符串是否为空或为null
StringUtils.isEmpty() 不包括空格的判断（若包含空格也为false） 但StringUtils.isBlank()更为严格（有空格判断为true）



token 认证方式的大致流程：
1.客户端使用用户名和密码请求登录。
2.服务端接收请求后，去验证用户名和密码。
3.验证成功后，服务端会签发一个token，再把这个token发送给客户端。
4.客户端收到token以后可以把它存储起来，比如放在cookie中。
5.客户端每次向服务器请求资源的时候需要带着服务器签发的token。
6.服务器收到请求后，然后去验证客户端请求里面带着的token，如果验证成功，就向客户端发送请求的数据。


token认证的的优点：
支持跨域访问：Cookie是不允许跨域访问的。这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP有传输。
无状态：token机制在服务端不需要存储session信息，因为Token自身包含了所有登陆用户的信息，只需要在客户端的Cookie或本地介质存储状态信息。
去耦：不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可。
更适用于移动应用：主要Cookie在一个原生平台的客户端是不被支持的，采用Token认证机制就会简单得多。
CSRF: 因为不再依赖于Cookie，所以你就不需要考虑对csrf（跨站请求伪造）的防范。
性能：通过数据库查询session信息（一次网络往返的时间）总比做一次HMACSHA256计算的Token验证和解析要费时的多。